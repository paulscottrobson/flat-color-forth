 
// ****************************************************************************************************
//
//		Compiles overrides the normal behaviour of a word, so you can make a word do something 
//		else when its compiled. Every red word has CALL <CompileCallToNextInstruction> compiled
//		in by default ; this removes it. It's sort of like "IMMEDIATE".
//
// ****************************************************************************************************

:compiles 
 	ab>r here 3- + h ! r>ab 						// Which does compiles.
;

// ****************************************************************************************************
//
//		This creates a function (__compile.variable.handler) which creates a call to __variable.handler
//		when it itself is compiled. So when the variable word below is run, this call causes 
//		CALL <__variable.handler to be compiled inline. So we do not need to know what the address 
//		of the variable handler is.
//
// ****************************************************************************************************

:__compile.variable.handler
:__variable.handler
	235 1, 33 1, r>a 2,
;

// ****************************************************************************************************
//
//		Defines a word as a variable.
//
// ****************************************************************************************************

:variable 
 	[compiles] 										// It's a compiles word, it executes this on compile.
 	compiles 										// Makes the word just defined compiles.
 	__compile.variable.handler  					// Creates a call to __variable handler which COMPILES
 													// a call to __variable_handler because thats what the word does
 	0 2, 											// Compiling $0000
;


:test variable break

// if then begin until (while ?) min and max ? requires proper < =

