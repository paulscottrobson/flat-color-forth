// ***************************************************************************************
// ***************************************************************************************
//
//		Name : 		system.fcf
//		Author :	Paul Robson (paul@robsons.org.uk)
//		Date : 		12th December 2018
//		Purpose :	Standard utility routines and structures
//
// ***************************************************************************************
// ***************************************************************************************
 
// ****************************************************************************************************
//
//		Compiles overrides the normal behaviour of a word, so you can make a word do something 
//		else when its compiled. Every red word has CALL <CompileCallToNextInstruction> compiled
//		in by default ; this removes it. It's sort of like "IMMEDIATE".
//
// ****************************************************************************************************

:compiles 
 	ab>r here 3- + h ! r>ab 						// Which does compiles.
;

// ****************************************************************************************************
//
//		This creates a function (__compile.variable.handler) which creates a call to __variable.handler
//		when it itself is compiled. So when the variable word below is run, this call causes 
//		CALL <__variable.handler to be compiled inline. So we do not need to know what the address 
//		of the variable handler is.
//
// ****************************************************************************************************

:__compile.variable.handler
:__variable.handler
	235 1, 33 1, r>a 2,
;

// ****************************************************************************************************
//
//						Defines a word as a variable. :<identifier> variable
//
// ****************************************************************************************************

:variable 
 	[compiles] 										// It's a compiles word, it executes this on compile.
 	compiles 										// Makes the word just defined compiles.
 	__compile.variable.handler  					// Creates a call to __variable handler which COMPILES
 													// a call to __variable_handler (Rule#1)
 													// which outputs ex de,hl ld hl,<tos>
 	0 2, 											// Compiling $0000
;

// ****************************************************************************************************
//
//		Fast variables. xx @@ and xx !! are functionally the same as xx @ and xx ! but are quicker
//		because the code is rewritten to use direct access. However, it only works with variables.
//		You can't do it with calculated things e.g. xx 3 + @
//
// ****************************************************************************************************

:@@ [compiles]
	here push 3- h +! 42 1, pop h !  				// Rewrites ex de,hl ; ld hl,x to ex de,hl;ld hl,(x)
;

:!! [compiles]
	here push 4- h +! 0 1, 34 1, pop h ! 			// Rewrites ex de,hl ; ld hl,x to nop ; ld (x),hl
;


:testv variable 

:demo1 99 testv @@ 98 testv !! 97 testv 96

// !! @@ if then begin until (while ?) min and max ? requires proper < =

